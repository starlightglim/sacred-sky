{"ast":null,"code":"export const fragmentShader = /* glsl */`\n  const int noiseOctaves = 8;\n\n  uniform vec2 uResolution;\n  uniform float uTime;\n  uniform bool uFrontLayer;\n  uniform float uCloudScale;\n  uniform float uTimeScale;\n  uniform float uSoftness;\n  uniform float uBrightness;\n  uniform float uDensity;\n  uniform float uTurbulence;\n  uniform float uNoiseFrequency;\n  uniform float uWaveIntensity;\n  uniform float uNoiseScale;\n\n  float saturate(float num) {\n    return clamp(num, 0.0, 1.0);\n  }\n\n  float rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n  }\n\n  float noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n      mix(rand(ip), rand(ip+vec2(1.0,0.0)), u.x),\n      mix(rand(ip+vec2(0.0,1.0)), rand(ip+vec2(1.0,1.0)), u.x), u.y);\n    return res*res;\n  }\n\n  vec2 rotate(vec2 uv) {\n    uv = uv + noise(uv*0.2)*uTurbulence;\n    float rot = 3.0 + sin(uTime * 0.001) * uWaveIntensity;\n    float sinRot = sin(rot);\n    float cosRot = cos(rot);\n    mat2 rotMat = mat2(cosRot, -sinRot, sinRot, cosRot);\n    return uv * rotMat;\n  }\n\n  float fbm(vec2 uv) {\n    float rot = 1.57;\n    float sinRot = sin(rot);\n    float cosRot = cos(rot);\n    float f = 0.0;\n    float total = 0.0;\n    float mul = 0.5;\n    mat2 rotMat = mat2(cosRot, -sinRot, sinRot, cosRot);\n    \n    for(int i = 0; i < noiseOctaves; i++) {\n      float loopedTime = mod(uTime * 0.00015 * uTimeScale * (1.0-mul), 1000.0);\n      vec2 noiseUv = uv * uNoiseFrequency + loopedTime;\n      f += noise(noiseUv) * mul * uNoiseScale;\n      total += mul * uNoiseScale;\n      uv *= 3.0;\n      uv = rotate(uv);\n      mul *= 0.5;\n    }\n    return f/total;\n  }\n\n  void main() {\n    vec2 screenUv = gl_FragCoord.xy/uResolution.xy;\n    vec2 uv = gl_FragCoord.xy/(40000.0*uCloudScale);\n    \n    float cover = uDensity;\n    float bright = uBrightness * (1.8-cover);\n    \n    float loopedTime1 = mod(uTime * 0.00004 * uTimeScale, 1000.0);\n    float loopedTime2 = mod(uTime * 0.00002 * uTimeScale, 1000.0);\n    \n    float color1 = fbm(uv - 0.5 + loopedTime1);\n    float color2 = fbm(uv - 10.5 + loopedTime2);\n    \n    float clouds1 = smoothstep(1.0-cover, min((1.0-cover)+uSoftness*2.0,1.0), color1);\n    float clouds2 = smoothstep(1.0-cover, min((1.0-cover)+uSoftness,1.0), color2);\n    \n    float cloudsFormComb = saturate(clouds1+clouds2);\n    \n    vec4 skyCol = vec4(0.6, 0.8, 1.0, 1.0);\n    float cloudCol = saturate(saturate(1.0-pow(color1,1.0)*0.2)*bright);\n    vec4 clouds1Color = vec4(cloudCol,cloudCol,cloudCol,1.0);\n    vec4 clouds2Color = mix(clouds1Color,skyCol,0.25);\n    vec4 cloudColComb = mix(clouds1Color,clouds2Color,saturate(clouds2-clouds1));\n    \n    gl_FragColor = mix(skyCol, cloudColComb, cloudsFormComb);\n  }\n`;","map":{"version":3,"names":["fragmentShader"],"sources":["/Users/yassin/Desktop/code/sacred-sky/src/components/CloudBackground/shaders.js"],"sourcesContent":["export const fragmentShader = /* glsl */ `\n  const int noiseOctaves = 8;\n\n  uniform vec2 uResolution;\n  uniform float uTime;\n  uniform bool uFrontLayer;\n  uniform float uCloudScale;\n  uniform float uTimeScale;\n  uniform float uSoftness;\n  uniform float uBrightness;\n  uniform float uDensity;\n  uniform float uTurbulence;\n  uniform float uNoiseFrequency;\n  uniform float uWaveIntensity;\n  uniform float uNoiseScale;\n\n  float saturate(float num) {\n    return clamp(num, 0.0, 1.0);\n  }\n\n  float rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n  }\n\n  float noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n      mix(rand(ip), rand(ip+vec2(1.0,0.0)), u.x),\n      mix(rand(ip+vec2(0.0,1.0)), rand(ip+vec2(1.0,1.0)), u.x), u.y);\n    return res*res;\n  }\n\n  vec2 rotate(vec2 uv) {\n    uv = uv + noise(uv*0.2)*uTurbulence;\n    float rot = 3.0 + sin(uTime * 0.001) * uWaveIntensity;\n    float sinRot = sin(rot);\n    float cosRot = cos(rot);\n    mat2 rotMat = mat2(cosRot, -sinRot, sinRot, cosRot);\n    return uv * rotMat;\n  }\n\n  float fbm(vec2 uv) {\n    float rot = 1.57;\n    float sinRot = sin(rot);\n    float cosRot = cos(rot);\n    float f = 0.0;\n    float total = 0.0;\n    float mul = 0.5;\n    mat2 rotMat = mat2(cosRot, -sinRot, sinRot, cosRot);\n    \n    for(int i = 0; i < noiseOctaves; i++) {\n      float loopedTime = mod(uTime * 0.00015 * uTimeScale * (1.0-mul), 1000.0);\n      vec2 noiseUv = uv * uNoiseFrequency + loopedTime;\n      f += noise(noiseUv) * mul * uNoiseScale;\n      total += mul * uNoiseScale;\n      uv *= 3.0;\n      uv = rotate(uv);\n      mul *= 0.5;\n    }\n    return f/total;\n  }\n\n  void main() {\n    vec2 screenUv = gl_FragCoord.xy/uResolution.xy;\n    vec2 uv = gl_FragCoord.xy/(40000.0*uCloudScale);\n    \n    float cover = uDensity;\n    float bright = uBrightness * (1.8-cover);\n    \n    float loopedTime1 = mod(uTime * 0.00004 * uTimeScale, 1000.0);\n    float loopedTime2 = mod(uTime * 0.00002 * uTimeScale, 1000.0);\n    \n    float color1 = fbm(uv - 0.5 + loopedTime1);\n    float color2 = fbm(uv - 10.5 + loopedTime2);\n    \n    float clouds1 = smoothstep(1.0-cover, min((1.0-cover)+uSoftness*2.0,1.0), color1);\n    float clouds2 = smoothstep(1.0-cover, min((1.0-cover)+uSoftness,1.0), color2);\n    \n    float cloudsFormComb = saturate(clouds1+clouds2);\n    \n    vec4 skyCol = vec4(0.6, 0.8, 1.0, 1.0);\n    float cloudCol = saturate(saturate(1.0-pow(color1,1.0)*0.2)*bright);\n    vec4 clouds1Color = vec4(cloudCol,cloudCol,cloudCol,1.0);\n    vec4 clouds2Color = mix(clouds1Color,skyCol,0.25);\n    vec4 cloudColComb = mix(clouds1Color,clouds2Color,saturate(clouds2-clouds1));\n    \n    gl_FragColor = mix(skyCol, cloudColComb, cloudsFormComb);\n  }\n`;"],"mappings":"AAAA,OAAO,MAAMA,cAAc,GAAG,UAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}